/**
 * Expert Agent Code Generator 
 * This generator uses the Strands expert agent service to generate production-ready code
 */

import { extractStructuredConfig, validateConfiguration } from './configExtractor';
import expertAgentService from '../services/expertAgentService';

export async function generateCodeWithExpertAgent(nodes, edges, settings = null, config = null, enableStreaming = false, onProgress = null) {
  try {


    // Step 1: Extract structured configuration from visual components
    const structuredConfig = extractStructuredConfig(nodes, edges);

    // Step 2: Validate configuration
    const validation = validateConfiguration(structuredConfig);

    if (validation.errors.length > 0) {
      return {
        success: false,
        code: null,
        errors: validation.errors,
        warnings: validation.warnings,
        approach: 'expert-agent'
      };
    }

    // Step 3: Check expert agent service health
    const healthCheck = await expertAgentService.checkHealth();

    if (!healthCheck.success || !healthCheck.expert_agent_ready) {
      return {
        success: false,
        code: null,
        errors: ['Expert agent service is not available. Please ensure the backend service is running.'],
        warnings: [],
        approach: 'expert-agent',
        serviceStatus: healthCheck
      };
    }



    // Step 4: Generate code using expert agent (with selected model)
    const expertAgentModel = settings?.expertAgentModel;
    
    let generationResult;
    if (enableStreaming && onProgress) {
      generationResult = await expertAgentService.generateCodeStreaming(structuredConfig, onProgress, expertAgentModel);
    } else {
      generationResult = await expertAgentService.generateCode(structuredConfig, expertAgentModel);
    }

    if (!generationResult.success) {
      return {
        success: false,
        code: null,
        errors: [generationResult.error || 'Code generation failed'],
        warnings: validation.warnings,
        approach: 'expert-agent',
        metadata: generationResult.metadata
      };
    }

    // Step 5: Post-process and validate generated code
    const processedCode = postProcessGeneratedCode(generationResult.code, structuredConfig);
    const codeValidation = validateGeneratedCode(processedCode);



    return {
      success: true,
      code: processedCode,
      errors: [],
      warnings: [...validation.warnings, ...codeValidation.warnings],
      approach: 'expert-agent',
      metadata: {
        ...generationResult.metadata,
        codeValidation,
        configSummary: {
          agentCount: structuredConfig.agents.length,
          toolCount: structuredConfig.tools.length,
          workflowType: structuredConfig.architecture.workflowType,
          complexity: structuredConfig.architecture.complexity,
          patterns: structuredConfig.architecture.patterns
        }
      }
    };

  } catch (error) {
    console.error('Expert agent code generation failed');

    return {
      success: false,
      code: null,
      errors: [`Expert agent generation failed: ${error.message}`],
      warnings: [],
      approach: 'expert-agent',
      metadata: {
        error: error.message,
        stack: error.stack
      }
    };
  }
}

/**
 * Post-process the generated code to ensure consistency and add enhancements
 */
function postProcessGeneratedCode(code, config) {
  if (!code) return '';

  let processedCode = code;

  // Add header comment with generation info
  const header = `# Generated by Strands Visual Builder - Expert Agent Approach
# Architecture: ${config.architecture.workflowType} (${config.architecture.complexity})
# Agents: ${config.agents.length}, Tools: ${config.tools.length}
# Generated: ${new Date().toISOString()}
# Patterns: ${config.architecture.patterns.join(', ') || 'None'}

`;

  // Add header if not already present
  if (!processedCode.includes('Generated by Strands Visual Builder')) {
    processedCode = header + processedCode;
  }

  // Ensure proper imports are present
  processedCode = ensureProperImports(processedCode, config);

  // Installation instructions are handled by backend prompt

  return processedCode;
}



/**
 * Ensure proper imports are present in the generated code
 */
function ensureProperImports(code, config) {
  const lines = code.split('\n');
  const imports = [];
  const nonImportLines = [];
  let inImportSection = true;

  // Separate imports from other code
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.startsWith('import ') || trimmed.startsWith('from ') || trimmed === '' || trimmed.startsWith('#')) {
      if (inImportSection) {
        imports.push(line);
      } else {
        nonImportLines.push(line);
      }
    } else {
      inImportSection = false;
      nonImportLines.push(line);
    }
  }

  // Check for required imports based on config
  const requiredImports = new Set();

  // Core Strands imports
  if (config.agents.length > 0) {
    requiredImports.add('from strands import Agent');
  }

  // Custom tools require tool decorator
  const hasCustomTools = config.tools.some(tool => tool.type === 'custom');
  if (hasCustomTools) {
    requiredImports.add('from strands import tool');
  }

  // Model imports based on agent configurations
  const needsBedrockModel = config.agents.some(agent =>
    agent.temperature !== undefined ||
    agent.maxTokens !== undefined ||
    !['claude-3-5-sonnet'].includes(agent.model)
  );

  if (needsBedrockModel) {
    requiredImports.add('from strands.models import BedrockModel');
  }

  // Tool imports
  const builtinTools = config.tools.filter(tool => tool.type === 'builtin');
  if (builtinTools.length > 0) {
    const toolNames = builtinTools.map(tool => tool.name);
    requiredImports.add(`from strands_tools import ${toolNames.join(', ')}`);
  }

  // Add missing imports
  const existingImports = imports.join('\n');
  const missingImports = Array.from(requiredImports).filter(imp =>
    !existingImports.includes(imp)
  );

  // Combine imports and code
  const allImports = [...imports, ...missingImports.map(imp => imp)];

  return [...allImports, '', ...nonImportLines].join('\n');
}

/**
 * Validate the generated code for completeness and correctness
 */
function validateGeneratedCode(code) {
  const validation = {
    hasStrandsImport: false,
    hasAgentCreation: false,
    hasToolImports: false,
    hasErrorHandling: false,
    hasUsageExample: false,
    hasComments: false,
    estimatedLines: 0,
    warnings: [],
    suggestions: []
  };

  if (!code) {
    validation.warnings.push('No code generated');
    return validation;
  }

  const lines = code.split('\n');
  validation.estimatedLines = lines.length;

  // Check for required patterns
  const codeContent = code.toLowerCase();

  // Strands imports
  if (code.includes('from strands import') || code.includes('import strands')) {
    validation.hasStrandsImport = true;
  } else {
    validation.warnings.push('Missing Strands import');
  }

  // Agent creation
  if (codeContent.includes('agent(')) {
    validation.hasAgentCreation = true;
  } else {
    validation.warnings.push('No Agent instantiation found');
  }

  // Tool imports
  if (code.includes('from strands_tools import')) {
    validation.hasToolImports = true;
  } else {
    validation.suggestions.push('Consider adding tool imports for enhanced functionality');
  }

  // Error handling
  if (code.includes('try:') && code.includes('except')) {
    validation.hasErrorHandling = true;
  } else {
    validation.suggestions.push('Consider adding error handling for production use');
  }

  // Usage example
  if (code.includes('__main__') || code.includes('if __name__')) {
    validation.hasUsageExample = true;
  } else {
    validation.suggestions.push('Consider adding usage examples');
  }

  // Comments and documentation
  const commentLines = lines.filter(line => line.trim().startsWith('#')).length;
  const docstringLines = lines.filter(line => line.includes('"""') || line.includes("'''")).length;

  if (commentLines > 5 || docstringLines > 0) {
    validation.hasComments = true;
  } else {
    validation.suggestions.push('Consider adding more documentation and comments');
  }

  return validation;
}

/**
 * Get service status for UI display
 */
export async function getExpertAgentStatus() {
  try {
    const [health, info] = await Promise.all([
      expertAgentService.checkHealth(),
      expertAgentService.getAgentInfo()
    ]);

    return {
      available: health.success && health.expert_agent_ready,
      status: health.status,
      capabilities: info.success ? info.capabilities : [],
      model: info.success ? info.model : 'Unknown',
      toolsCount: info.success ? info.tools_count : 0,
      lastChecked: new Date().toISOString()
    };
  } catch (error) {
    return {
      available: false,
      status: 'error',
      error: error.message,
      lastChecked: new Date().toISOString()
    };
  }
}

/**
 * Test the expert agent service connection
 */
export async function testExpertAgentConnection() {
  return await expertAgentService.testConnection();
}

/**
 * Get available generation approaches
 */
export function getAvailableApproaches() {
  return [
    {
      id: 'expert-agent',
      name: 'Expert Agent',
      description: 'Uses Strands expert agent for intelligent code generation',
      advantages: [
        'Intelligent architecture analysis',
        'Best practice application',
        'Advanced error handling',
        'Self-extending agent patterns',
        'Production-ready code'
      ],
      requirements: [
        'Backend service running',
        'AWS credentials configured',
        'Internet connection'
      ]
    },
    {
      id: 'static-template',
      name: 'Static Templates',
      description: 'Uses predefined templates for code generation',
      advantages: [
        'Fast generation',
        'No external dependencies',
        'Predictable output',
        'Works offline'
      ],
      requirements: [
        'None'
      ]
    }
  ];
}

/**
 * Get available models for the UI
 */
export function getAvailableModels() {
  return [
    {
      id: 'us.anthropic.claude-3-5-sonnet-20241022-v2:0',
      name: 'Claude 3.5 Sonnet',
      provider: 'Anthropic',
      displayId: 'claude-3-5-sonnet'
    },
    {
      id: 'us.anthropic.claude-3-haiku-20240307-v1:0',
      name: 'Claude 3.5 Haiku',
      provider: 'Anthropic',
      displayId: 'claude-3-5-haiku'
    },
    {
      id: 'us.anthropic.claude-3-opus-20240229-v1:0',
      name: 'Claude 3 Opus',
      provider: 'Anthropic',
      displayId: 'claude-3-opus'
    },
    {
      id: 'us.amazon.nova-pro-v1:0',
      name: 'Nova Pro',
      provider: 'Amazon',
      displayId: 'nova-pro'
    },
    {
      id: 'us.amazon.nova-lite-v1:0',
      name: 'Nova Lite',
      provider: 'Amazon',
      displayId: 'nova-lite'
    },
    {
      id: 'us.amazon.nova-micro-v1:0',
      name: 'Nova Micro',
      provider: 'Amazon',
      displayId: 'nova-micro'
    }
  ];
}

/**
 * Get available builtin tools for the component palette
 * Now fetches dynamically from the backend
 */
export async function getAvailableTools() {
  try {
    const apiBaseUrl = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8080';
    const response = await fetch(`${apiBaseUrl}/api/available-tools`);
    const data = await response.json();
    
    if (data.success) {
      return data.tools;
    } else {
      console.error('Failed to fetch tools from backend');
      return getFallbackTools();
    }
  } catch (error) {
    console.error('Error fetching tools from backend');
    return getFallbackTools();
  }
}

/**
 * Fallback tools list in case backend is not available
 */
function getFallbackTools() {
  return [
    { name: 'calculator', type: 'builtin', description: 'Perform mathematical calculations', category: 'Utilities' },
    { name: 'shell', type: 'builtin', description: 'Execute shell commands', category: 'System' },
    { name: 'python_repl', type: 'builtin', description: 'Run Python code', category: 'System' },
    { name: 'file_read', type: 'builtin', description: 'Read file contents', category: 'File Operations' },
    { name: 'file_write', type: 'builtin', description: 'Write content to files', category: 'File Operations' },
    { name: 'current_time', type: 'builtin', description: 'Get current date and time', category: 'Utilities' },
    { name: 'http_request', type: 'builtin', description: 'Make HTTP API requests', category: 'Web & APIs' },
    { name: 'use_aws', type: 'builtin', description: 'Interact with AWS services', category: 'AWS Services' },
    { name: 'generate_image', type: 'builtin', description: 'Generate images with AI', category: 'Media' },
    { name: 'image_reader', type: 'builtin', description: 'Process and analyze images', category: 'Media' },
    { name: 'journal', type: 'builtin', description: 'Log and retrieve information', category: 'Utilities' },
    { name: 'environment', type: 'builtin', description: 'Manage environment variables', category: 'System' },
    { name: 'editor', type: 'builtin', description: 'Advanced file editing', category: 'File Operations' },
    { name: 'memory', type: 'builtin', description: 'Store and retrieve memories', category: 'AWS Services' },
    { name: 'retrieve', type: 'builtin', description: 'Query knowledge bases', category: 'AWS Services' },
    { name: 'nova_reels', type: 'builtin', description: 'Create video content', category: 'Media' }
  ];
}

export default {
  generateCodeWithExpertAgent,
  getExpertAgentStatus,
  testExpertAgentConnection,
  getAvailableApproaches,
  getAvailableModels,
  getAvailableTools
};